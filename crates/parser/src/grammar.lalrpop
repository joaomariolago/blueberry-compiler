use crate::ast::*;

grammar;

pub IdlFile: Vec<Definition> = {
    <defs:Definition*> => defs
};

// Comment parsing rules
Comment: String = {
    r"//[^\n]*" => {
        let text = <>.trim_start_matches("//").trim_start();
        text.to_string()
    },
    r"/\*([^*]|\*+[^*/])*\*+/" => {
        let raw = <>;
        let without_start = raw.trim_start_matches("/*");
        let without_end = without_start.trim_end_matches("*/");
        without_end
            .trim()
            .lines()
            .map(|line| line.trim_start())
            .collect::<Vec<_>>()
            .join("\n")
    },
};

CommentList: Vec<String> = {
    => vec![],
    <c:Comment> <rest:CommentList> => {
        let mut list = vec![c];
        list.extend(rest);
        list
    }
};

AnnotationParam: AnnotationParam = {
    <id:Identifier> "=" <value:ConstValue> => AnnotationParam::Named {
        name: id,
        value,
    },
};

AnnotationParamList: Vec<AnnotationParam> = {
    <p:AnnotationParam> => vec![p],
    <p:AnnotationParam> "," <rest:AnnotationParamList> => {
        let mut list = vec![p];
        list.extend(rest);
        list
    }
};

Annotation: Annotation = {
    // With parameters: @MyAnn(foo = 1, bar = "x")
    "@" <name:ScopedName> "(" <params:AnnotationParamList> ")" => Annotation {
        name,
        params,
    },

    // No-parameter form must be written as @MyAnn()
    "@" <name:ScopedName> "(" ")" => Annotation {
        name,
        params: Vec::new(),
    },
};

AnnotationList: Vec<Annotation> = {
    => vec![],
    <a:Annotation> <rest:AnnotationList> => {
        let mut list = vec![a];
        list.extend(rest);
        list
    }
};

Definition: Definition = {
    <comments:CommentList> <annotations:AnnotationList> <m:ModuleDef> => {
        Definition::ModuleDef(Commented::with_annotations(m, comments, annotations))
    },
    <comments:CommentList> <annotations:AnnotationList> <t:TypeDef> => {
        Definition::TypeDef(Commented::with_annotations(t, comments, annotations))
    },
    <comments:CommentList> <annotations:AnnotationList> <e:EnumDef> => {
        Definition::EnumDef(Commented::with_annotations(e, comments, annotations))
    },
    <comments:CommentList> <annotations:AnnotationList> <s:StructDef> => {
        Definition::StructDef(Commented::with_annotations(s, comments, annotations))
    },
    <comments:CommentList> <annotations:AnnotationList> <c:ConstDef> => {
        Definition::ConstDef(Commented::with_annotations(c, comments, annotations))
    },
    <comments:CommentList> <annotations:AnnotationList> <i:ImportDef> => {
        Definition::ImportDef(Commented::with_annotations(i, comments, annotations))
    },
};

ModuleDef: ModuleDef = {
    "module" <name:Identifier> "{" <defs:Definition*> "}" ";" => ModuleDef {
        name,
        definitions: defs,
    }
};

TypeDef: TypeDef = {
    "typedef" <base_type:Type> <name:Identifier> <dims:ArrayDimensions> ";" => {
        let base_type = if dims.is_empty() {
            base_type
        } else {
            Type::Array {
                element_type: Box::new(base_type),
                dimensions: dims,
            }
        };
        TypeDef {
            base_type,
            name,
        }
    }
};

ConstDef: ConstDef = {
    "const" <const_type:Type> <name:Identifier> "=" <value:ConstValue> ";" => ConstDef {
        const_type,
        name,
        value,
    }
};

ImportDef: ImportDef = {
    "import" <scope:ImportedScope> ";" => ImportDef { scope }
};

ImportedScope: ImportScope = {
    <name:ScopedName> => ImportScope::Scoped(name),
    <path:StringLiteral> => ImportScope::String(path),
};

EnumDef: EnumDef = {
    "enum" <name:Identifier> <base:EnumBaseType?> "{" <enumerators:EnumMemberList> "}" ";" => EnumDef {
        name,
        base_type: base,
        enumerators,
    }
};

EnumBaseType: Type = {
    ":" <type_:Type> => type_,
};

EnumMemberList: Vec<EnumMember> = {
    => vec![],
    <entry:EnumMember> <rest:EnumMemberTail> => {
        let mut list = vec![entry];
        list.extend(rest);
        list
    }
};

EnumMemberTail: Vec<EnumMember> = {
    => vec![],
    <_sep:EnumSeparator> <rest:EnumMemberList> => rest,
};

EnumSeparator: () = {
    "," => (),
    ";" => (),
};

EnumMember: EnumMember = {
    <comments:CommentList> <name:Identifier> <value:EnumValue?> => EnumMember {
        name,
        value,
        comments,
    }
};

EnumValue: ConstValue = {
    "=" <value:ConstValue> => value,
};

StructDef: StructDef = {
    "struct" <name:Identifier> "{" <members:MemberList> "}" ";" => StructDef {
        name,
        members,
    }
};

MemberList: Vec<Commented<Member>> = {
    => vec![],
    <comments:CommentList> <annotations:AnnotationList> <m:Member> <rest:MemberList> => {
        let mut list = vec![Commented::with_annotations(m, comments, annotations)];
        list.extend(rest);
        list
    }
};

Member: Member = {
    <type_:Type> <name:Identifier> <dims:ArrayDimensions> ";" => {
        // Apply array dimensions to the type if present
        let final_type = if dims.is_empty() {
            type_
        } else {
            Type::Array {
                element_type: Box::new(type_),
                dimensions: dims,
            }
        };
        Member {
            type_: final_type,
            name,
        }
    }
};

ArrayDimensions: Vec<u32> = {
    => vec![],
    "[" <dim:PositiveInteger> "]" <rest:ArrayDimensions> => {
        let mut dims = vec![dim];
        dims.extend(rest);
        dims
    }
};

Type: Type = {
    // all 'long' variants go through LongSuffix
    "long" <k:LongSuffix> => k,
    "short" => Type::Short,
    "uint8" => Type::Octet,
    "uint16" => Type::UnsignedShort,
    "uint32" => Type::UnsignedLong,
    "uint64" => Type::UnsignedLongLong,
    "float" => Type::Float,
    "double" => Type::Double,
    "boolean" => Type::Boolean,
    "char" => Type::Char,
    "wchar" => Type::WChar,
    "octet" => Type::Octet,
    "string" => Type::String,
    "wstring" => Type::WString,

    // Sequence type
    "sequence" "<" <element_type:Type> ">" => Type::Sequence {
        element_type: Box::new(element_type),
        size: None,
    },
    "sequence" "<" <element_type:Type> "," <size:PositiveInteger> ">" => Type::Sequence {
        element_type: Box::new(element_type),
        size: Some(size),
    },

    // Scoped names (user-defined types)
    <name:ScopedName> => Type::ScopedName(name),
};

LongSuffix: Type = {
    "long" => Type::LongLong,
    "double" => Type::LongDouble,
    // bare "long"
    => Type::Long,
};

ConstValue: ConstValue = {
    <expr:AddExpr> => expr,
};

AddExpr: ConstValue = {
    <left:AddExpr> "+" <right:MulExpr> => ConstValue::BinaryOp {
        op: BinaryOperator::Add,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:AddExpr> "-" <right:MulExpr> => ConstValue::BinaryOp {
        op: BinaryOperator::Subtract,
        left: Box::new(left),
        right: Box::new(right),
    },
    <MulExpr>,
};

MulExpr: ConstValue = {
    <left:MulExpr> "*" <right:UnaryExpr> => ConstValue::BinaryOp {
        op: BinaryOperator::Multiply,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:MulExpr> "/" <right:UnaryExpr> => ConstValue::BinaryOp {
        op: BinaryOperator::Divide,
        left: Box::new(left),
        right: Box::new(right),
    },
    <UnaryExpr>,
};

UnaryExpr: ConstValue = {
    "+" <expr:UnaryExpr> => ConstValue::UnaryOp {
        op: UnaryOperator::Plus,
        expr: Box::new(expr),
    },
    "-" <expr:UnaryExpr> => ConstValue::UnaryOp {
        op: UnaryOperator::Minus,
        expr: Box::new(expr),
    },
    <PrimaryExpr>,
};

PrimaryExpr: ConstValue = {
    "(" <expr:AddExpr> ")" => expr,
    <LiteralValue>,
};

LiteralValue: ConstValue = {
    <i:IntegerLiteral> => ConstValue::Integer(i),
    <f:FloatLiteral> => ConstValue::Float(f),
    <fx:FixedLiteral> => ConstValue::Fixed(fx),
    <s:StringLiteral> => ConstValue::String(s),
    "TRUE" => ConstValue::Boolean(true),
    "FALSE" => ConstValue::Boolean(false),
    <c:CharLiteral> => ConstValue::Char(c),
    <name:ScopedName> => ConstValue::ScopedName(name),
};

IntegerLiteral: IntegerLiteral = {
    r"-?0[xX][0-9a-fA-F]+" => IntegerLiteral::from_hex_str(<>),
    r"-?0[0-7]+" => IntegerLiteral::from_octal_str(<>),
    r"-?0" => IntegerLiteral::from_octal_str(<>),
    r"-?[1-9][0-9]*" => IntegerLiteral::from_decimal_str(<>),
};

FloatLiteral: f64 = {
    r"-?[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?" => <>.parse().unwrap(),
    r"-?\.[0-9]+([eE][+-]?[0-9]+)?" => <>.parse().unwrap(),
    r"-?[0-9]+[eE][+-]?[0-9]+" => <>.parse().unwrap(),
};

FixedLiteral: FixedPointLiteral = {
    r"-?[0-9]+\.[0-9]+[dD]" => FixedPointLiteral::from_literal_str(<>),
    r"-?\.[0-9]+[dD]" => FixedPointLiteral::from_literal_str(<>),
    r"-?[0-9]+\.[dD]" => FixedPointLiteral::from_literal_str(<>),
    r"-?[0-9]+[dD]" => FixedPointLiteral::from_literal_str(<>),
};

StringLiteral: String = {
    r#""([^"\\]|\\.)*""# => {
        let s = <>.to_string();
        // Remove quotes and unescape
        let mut chars = s.chars();
        chars.next(); // skip opening quote
        chars.next_back(); // skip closing quote
        chars.collect::<String>()
            .replace("\\n", "\n")
            .replace("\\t", "\t")
            .replace("\\r", "\r")
            .replace("\\\\", "\\")
            .replace("\\\"", "\"")
    }
};

CharLiteral: char = {
    r"'([^'\\]|\\.)'" => {
        let s = <>.to_string();
        let mut chars = s.chars();
        chars.next(); // skip opening quote
        chars.next_back(); // skip closing quote
        let ch = chars.collect::<String>();
        if ch.starts_with('\\') {
            match ch.as_str() {
                "\\n" => '\n',
                "\\t" => '\t',
                "\\r" => '\r',
                "\\\\" => '\\',
                "\\'" => '\'',
                _ => ch.chars().next().unwrap_or('\0'),
            }
        } else {
            ch.chars().next().unwrap_or('\0')
        }
    }
};

ScopedName: Vec<String> = {
    // relative name:  id [:: id]*
    <id:Identifier> <rest:ScopedNameTail*> => {
        let mut list = vec![id];
        list.extend(rest);
        list
    },

    // absolute name: ::id [:: id]*
    "::" <id:Identifier> <rest:ScopedNameTail*> => {
        let mut list = vec![id];
        list.extend(rest);
        list
    },
};

ScopedNameTail: String = {
    "::" <id:Identifier> => id,
};

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
};

PositiveInteger: u32 = {
    <i:IntegerLiteral> => {
        if i.value >= 0 {
            i.value as u32
        } else {
            panic!("Expected positive integer, got negative")
        }
    }
};
